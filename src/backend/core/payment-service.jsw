// backend/core/payment-service.jsw
import wixData from 'wix-data';
import { fetch } from 'wix-fetch';
import { getPaystackSecretKey, PAYSTACK_CONFIG } from 'backend/paystack-config.jsw';
import { verifyAndSyncPayment } from 'backend/core/payment-verifier.jsw';

export class PaymentService {
  static async detectSignupPayment(userId, email, reference = null, provider = null) {
    try {
      // 1) Our own transactions table (best, if you record Paystack/PayFast there)
      const psTx = await wixData.query('PaystackTransactions')
        .eq('userId', userId)
        .eq('transactionType', 'signup_fee')
        .eq('status', 'success')
        .limit(1)
        .find({ suppressAuth: true })
        .catch(() => ({ items: [] }));

      if (psTx.items.length) {
        const tx = psTx.items[0];
        return {
          success: true,
          paymentDetected: true,
          provider: 'paystack',
          amount: tx.amount,
          reference: tx._id,
          confidence: 100,
          paymentDate: tx.createdAt,
          source: 'PaystackTransactions'
        };
      }

      // 2) CMS profile flags
      const prof = await wixData.query('Emergency_Profiles')
        .eq('_owner', userId)
        .limit(1)
        .find({ suppressAuth: true });

      if (prof.items.length) {
        const p = prof.items[0];
        if (p.signUpPaid && p.signUpReference) {
          return {
            success: true,
            paymentDetected: true,
            provider: p.paymentProvider || 'unknown',
            reference: p.signUpReference,
            confidence: 85,
            paymentDate: p.joinedDate,
            source: 'Emergency_Profiles'
          };
        }
      }

      // 3) Live verification (when redirected back with ?reference & gateway)
      if (reference && provider) {
        const confirm = await verifyAndSyncPayment({ userId, reference, provider });
        if (confirm.success) {
          return {
            success: true,
            paymentDetected: true,
            provider,
            reference,
            confidence: 100,
            source: 'gateway_verification'
          };
        }
      }

      // 4) Optional: Paystack API lookup by email (works when email maps to customer)
      try {
        const key = await getPaystackSecretKey();
        const r = await fetch(`${PAYSTACK_CONFIG.API_BASE_URL}/customer?email=${encodeURIComponent(email)}`, {
          headers: { Authorization: `Bearer ${key}` }
        });
        const j = await r.json();
        const customerId = j?.data?.[0]?.id;
        if (customerId) {
          const r2 = await fetch(`${PAYSTACK_CONFIG.API_BASE_URL}/transaction?customer=${encodeURIComponent(customerId)}&status=success`, {
            headers: { Authorization: `Bearer ${key}` }
          });
          const j2 = await r2.json();
          const signup = (j2.data || []).find(tx => (tx.metadata?.purpose || tx.metadata?.transaction_type) === 'signup_fee');
          if (signup) {
            return {
              success: true,
              paymentDetected: true,
              provider: 'paystack',
              amount: signup.amount / 100,
              reference: signup.reference,
              confidence: 90,
              paymentDate: signup.paid_at || signup.created_at,
              source: 'PaystackAPI'
            };
          }
        }
      } catch (_) {}

      return { success: true, paymentDetected: false, confidence: 0, source: 'not_found' };
    } catch (err) {
      console.error('[PaymentService.detectSignupPayment] error:', err);
      return { success: false, paymentDetected: false, confidence: 0, error: err.message };
    }
  }

  static async detectActiveSubscription(userId, email) {
    try {
      const key = await getPaystackSecretKey();

      // Search customer â†’ subscriptions
      const cust = await fetch(`${PAYSTACK_CONFIG.API_BASE_URL}/customer?email=${encodeURIComponent(email)}`, {
        headers: { Authorization: `Bearer ${key}` }
      }).then(r => r.json()).catch(() => ({}));

      const customerId = cust?.data?.[0]?.customer_code || cust?.data?.[0]?.id;
      if (!customerId) return { success: true, hasActiveSubscription: false, confidence: 100 };

      const subs = await fetch(`${PAYSTACK_CONFIG.API_BASE_URL}/subscription?customer=${encodeURIComponent(customerId)}`, {
        headers: { Authorization: `Bearer ${key}` }
      }).then(r => r.json()).catch(() => ({}));

      const active = (subs.data || []).filter(s =>
        s.status === 'active' && new Date(s.next_payment_date) > new Date()
      );

      if (active.length) {
        const s = active[0];
        return {
          success: true,
          hasActiveSubscription: true,
          subscriptionCode: s.subscription_code,
          planName: s.plan?.name || 'Unknown',
          status: s.status,
          nextPaymentDate: new Date(s.next_payment_date),
          confidence: 100
        };
      }

      return { success: true, hasActiveSubscription: false, confidence: 100 };
    } catch (err) {
      console.error('[PaymentService.detectActiveSubscription] error:', err);
      return { success: false, error: err.message };
    }
  }

  static async syncPaymentStatus(userId, paymentData) {
    try {
      const q = await wixData.query('Emergency_Profiles')
        .eq('_owner', userId)
        .limit(1)
        .find({ suppressAuth: true });

      if (!q.items.length) return { success: false, error: 'Profile not found' };

      const existing = q.items[0];
      const update = {
        _id: existing._id,
        signUpPaid: paymentData.signUpPaid ?? existing.signUpPaid,
        signUpReference: paymentData.reference ?? existing.signUpReference,
        paymentProvider: paymentData.provider ?? existing.paymentProvider,
        subscriptionActive: paymentData.subscriptionActive ?? existing.subscriptionActive,
        membershipTier: paymentData.membershipTier ?? existing.membershipTier,
        lastUpdated: new Date()
      };

      const updated = await wixData.update('Emergency_Profiles', update, { suppressAuth: true });
      return { success: true, updatedProfile: updated };
    } catch (err) {
      console.error('[PaymentService.syncPaymentStatus] error:', err);
      return { success: false, error: err.message };
    }
  }
}

export async function detectSignupPayment(...args) { return PaymentService.detectSignupPayment(...args); }
export async function detectActiveSubscription(...args) { return PaymentService.detectActiveSubscription(...args); }
export async function syncPaymentStatus(...args) { return PaymentService.syncPaymentStatus(...args); }
