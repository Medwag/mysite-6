// === backend/paystack.jsw ===
// âœ… Merged version: combines your existing payment init + extended logic

import { fetch } from 'wix-fetch';
import wixData from 'wix-data';
import wixUsersBackend from 'wix-users-backend';
import { getPaystackSecretKey, PAYSTACK_CONFIG } from 'backend/paystack-config.jsw';
import { sendDiscordLog } from 'backend/logger.jsw';
import { getOrCreateProfile, updateProfile } from 'backend/profile-utils.jsw';

// ----------------------------------------------------
// ðŸ§© Helpers
// ----------------------------------------------------
async function authHeader() {
  const key = await getPaystackSecretKey();
  return { Authorization: `Bearer ${key}`, 'Content-Type': 'application/json' };
}

function getSiteUrl() {
  return 'https://www.emergitag.me';
}

// ----------------------------------------------------
// 1ï¸âƒ£ Once-off Sign-up Fee (existing function, retained)
// ----------------------------------------------------
export async function createPaystackPayment(userId, email) {
  const secretKey = await getPaystackSecretKey();
  const url = `${PAYSTACK_CONFIG.API_BASE_URL}/transaction/initialize`;

  const payload = {
    email,
    amount: 15000, // 150 ZAR in kobo
    metadata: { userId, purpose: "signup_fee" },
    callback_url: `${getSiteUrl()}/signup-success`
  };

  const response = await fetch(url, {
    method: "POST",
    headers: {
      "Authorization": `Bearer ${secretKey}`,
      "Content-Type": "application/json"
    },
    body: JSON.stringify(payload)
  });

  const result = await response.json();
  sendDiscordLog("ðŸ“¤ Paystack init: " + JSON.stringify(result));
  if (!result.status) throw new Error(result.message || "Paystack init failed");
  return result.data.authorization_url;
}

// ----------------------------------------------------
// 2ï¸âƒ£ Verify Sign-up Fee Payment
// ----------------------------------------------------
export async function verifyPaystackRef(reference) {
  const r = await fetch(`${PAYSTACK_CONFIG.API_BASE_URL}/transaction/verify/${reference}`, {
    headers: await authHeader()
  });
  const j = await r.json();
  if (!j.status) throw new Error(j.message || 'Verification failed');
  return j.data;
}

// ----------------------------------------------------
// 3ï¸âƒ£ Create/Get a Paystack Plan (monthly / yearly)
// ----------------------------------------------------
export async function ensurePaystackPlan({ name, interval, amountKobo, description }) {
  const body = { name, interval, amount: amountKobo, description };
  const r = await fetch(`${PAYSTACK_CONFIG.API_BASE_URL}/plan`, {
    method: 'post',
    headers: await authHeader(),
    body: JSON.stringify(body)
  });
  const j = await r.json();
  if (!j.status) throw new Error(j.message || 'Create plan failed');
  return j.data; // { plan_code, ... }
}

// ----------------------------------------------------
// 4ï¸âƒ£ Create a Subscription (using authorization from first charge)
// ----------------------------------------------------
export async function createPaystackSubscription({ customerEmail, planCode, authorizationCode }) {
  const body = { customer: customerEmail, plan: planCode, authorization: authorizationCode };
  const r = await fetch(`${PAYSTACK_CONFIG.API_BASE_URL}/subscription`, {
    method: 'post',
    headers: await authHeader(),
    body: JSON.stringify(body)
  });
  const j = await r.json();
  if (!j.status) throw new Error(j.message || 'Create subscription failed');
  sendDiscordLog(`âœ… Paystack Subscription Created: ${JSON.stringify(j.data)}`);
  return j.data;
}

// ----------------------------------------------------
// 5ï¸âƒ£ Finalize Signup (after returning from Paystack)
// ----------------------------------------------------
export async function finalizeSignupFromReference({ reference, membershipTier, planCode }) {
  const data = await verifyPaystackRef(reference);
  if (data.status !== 'success') throw new Error('Payment not successful');

  const auth = data.authorization; // contains authorization_code
  const customerEmail = data.customer?.email;

  const profile = await getOrCreateProfile();
  await updateProfile({
    // keep both keys for backward-compat
    signUpPaid: true,
    signupPaid: true,
    signupAmount: data.amount / 100,
    signupGateway: 'paystack',
    paystackCustomerId: data.customer?.id ? String(data.customer.id) : '',
    paystackAuthCode: auth?.authorization_code || '',
    membershipTier,
    planCode,
    lastPaymentDate: new Date()
  });

  // Auto-create subscription if planCode provided
  if (planCode && auth?.authorization_code) {
    try {
      const sub = await createPaystackSubscription({
        customerEmail,
        planCode,
        authorizationCode: auth.authorization_code
      });
      await updateProfile({
        subscriptionId: sub.subscription_code,
        subscriptionStatus: 'active',
        subscriptionActive: true
      });
      sendDiscordLog(`ðŸ’³ Subscription Activated for ${customerEmail} (${planCode})`);
    } catch (err) {
      sendDiscordLog(`âš ï¸ Subscription creation failed for ${customerEmail}: ${err.message}`);
    }
  }

  return { ok: true, data };
}

// ----------------------------------------------------
// 6ï¸âƒ£ Utility - Create customer if needed
// ----------------------------------------------------
export async function createPaystackCustomer(email) {
  const body = { email };
  const r = await fetch(`${PAYSTACK_CONFIG.API_BASE_URL}/customer`, {
    method: 'post',
    headers: await authHeader(),
    body: JSON.stringify(body)
  });
  const j = await r.json();
  if (!j.status) throw new Error(j.message || 'Customer creation failed');
  sendDiscordLog(`ðŸ‘¤ Paystack customer created: ${JSON.stringify(j.data)}`);
  return j.data;
}

// Minimal stub used by dashboard pages; replace with real implementation if needed
export async function getUserSubscriptionDetails(userId) {
  try {
    if (!userId) throw new Error('userId is required');

    // 1) Resolve email for customer lookup
    let email = null;
    try {
      const profQ = await wixData.query('Emergency_Profiles')
        .eq('_owner', userId)
        .limit(1)
        .find({ suppressAuth: true });
      if (profQ.items.length) {
        email = profQ.items[0].emailAddress || profQ.items[0].email || null;
      }
    } catch (_) {}

    if (!email) {
      try {
        const user = await wixUsersBackend.getUser(userId);
        email = user?.contactDetails?.emails?.[0]?.email || null;
      } catch (_) {}
    }

    if (!email) return { error: 'email_not_found' };

    // 2) Find Paystack customer by email
    const custRes = await fetch(`${PAYSTACK_CONFIG.API_BASE_URL}/customer?email=${encodeURIComponent(email)}`, {
      headers: await authHeader()
    });
    const custJson = await custRes.json();
    const customer = Array.isArray(custJson?.data) ? custJson.data[0] : null;
    const customerCode = customer?.customer_code || customer?.id;
    if (!customerCode) return { status: 'inactive', planName: null };

    // 3) Fetch subscriptions for the customer
    const subRes = await fetch(`${PAYSTACK_CONFIG.API_BASE_URL}/subscription?customer=${encodeURIComponent(customerCode)}`, {
      headers: await authHeader()
    });
    const subJson = await subRes.json();
    const subs = Array.isArray(subJson?.data) ? subJson.data : [];
    if (!subs.length) return { status: 'inactive', planName: null };

    // Prefer active, else the most recent by next_payment_date
    const active = subs.filter(s => s.status === 'active');
    const chosen = (active.length ? active : subs)
      .sort((a, b) => new Date(b.next_payment_date || 0) - new Date(a.next_payment_date || 0))[0];

    return {
      status: chosen?.status || 'inactive',
      planName: chosen?.plan?.name || null,
      subscription_code: chosen?.subscription_code || null,
      email,
      nextPaymentDate: chosen?.next_payment_date ? new Date(chosen.next_payment_date) : null
    };
  } catch (e) {
    return { error: e?.message || String(e) };
  }
}
